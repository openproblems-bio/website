![](/images/heros/anndata_schema.png){class="dataset_img"}

```{r load_data}
#| include: false
#| error: true

library(tidyverse)
library(jsonlite)
library(knitr)

# find files
dataset_schemas <- list.files(params$data_dir, full.names = TRUE, pattern = "*.json")

# read dataset metadata
#  -> add shape
metas <- lapply(dataset_schemas, function(file) {
  out <- read_json(file)
  out$file_name <- gsub(".*/dataset_metadata(.*)\\.json", "dataset\\1", file)
  out
})
names(metas) <- map_chr(metas, "file_name")

# extract metadata
uns <- metas[[1]]$uns
shape <-
  if (length(metas[[1]]$struct$layers) > 0) {
    metas[[1]]$struct$layers[[1]]$shape
  } else {
    NULL
  }
shape_str <- paste(shape, collapse = " × ")

file_size <- sum(sapply(metas, function(x) x$uns$file_size))
file_size_str <- format(
  structure(file_size, class = "object_size"),
  units = "auto",
  standard = "IEC",
  digits = 2
)

struc_names <- c("X", "obs", "var", "obsp", "varp", "obsm", "varm", "layers", "uns")

# collect struct info across files
slot_info <- list_rbind(map2(
  names(metas),
  metas,
  function(file_name, meta) {
    list_rbind(map2(
      names(meta$structure),
      meta$structure,
      function(name, slots) {
        if (length(slots) == 0) {
          return(NULL)
        }
        list_rbind(map(
          slots,
          function(li) {
            li$file_name <- file_name
            li$struct_name <- name
            # fix rendering of dtype when type is dataframe
            li$dtype <- paste0(li$dtype, collapse = ", ")
            for (n in names(li)) {
              if (is.null(li[[n]])) {
                li[[n]] <- NULL
              } else if (length(li[[n]]) > 1) {
                li[[n]] <- list(li[[n]])
              }
            }
            tibble::as_tibble(li)
          }
        ))
      }
    ))
  }
)) %>%
  mutate(
    shape_str = map_chr(shape, paste, collapse = " × "),
    internal_reference = paste0("#", file_name, "-slots-", struct_name, "-", name),
    type_str = case_when(
      type == "atomic" ~ "value",
      type == "densematrix" ~ "Dense matrix",
      type == "sparsematrix" ~ "Sparse matrix",
      type == "dataframe" ~ "Data frame",
      type == "vector" ~ "List",
      type == "dict" ~ "Dictionary",
      grepl("other:", type) ~ paste0("Other (`", gsub("other: ", "", type), "`)")
    ),
    data_type_str = case_when(
      dtype == "bool" ~ "Boolean",
      dtype == "int" ~ "Integer",
      dtype == "float32" ~ "Real",
      dtype == "float64" ~ "Real",
      dtype == "str" ~ "String",
      TRUE ~ NA_character_
    )
  )

```

---
dataset-size: "`r file_size_str`"
date: "`r uns$date_created`"
dimension: "`r shape_str`"
---



```{r quick-links, results='asis'}
#| echo: false
#| column: margin

cat(glue::glue("#### Quick links

<div class='quarto-title-meta-heading'><i class='bi bi-file-earmark-text'></i> [Documentation]({uns$dataset_url})</div>
<div class='quarto-title-meta-heading'><i class='bi bi-globe'></i> [Source]({uns$data_url})</div>
"))


```

```{r related benchmarks, results='asis'}
#| echo: false
#| column: margin

cat("#### Related benchmarks\n")

results_glob <- paste0(params$results_dir, "/*/data/dataset_info.json")
dataset_info_files <- Sys.glob(results_glob)

rel_benchmarks <- NULL

for (file in dataset_info_files) {
  benchm_datasets <- read_json(file)
  benchmark_ok <- FALSE
  for (item in benchm_datasets) {
    if (item$dataset_id == rmarkdown::metadata$`dataset-id`[1]) {
      benchmark_ok <- TRUE
    }
  }

  if (benchmark_ok) {
    parent_dir <- dirname(dirname(file))
    md_link <- paste0('[',basename(parent_dir),'](',parent_dir,')')
    rel_benchmarks <- c(rel_benchmarks, md_link)
  }
}

if (length(rel_benchmarks) == 0) {
  cat("No related benchmarks found.\n")
}

table <- kable(rel_benchmarks,"markdown", col.names = NULL)
print(table)

```

## Description

```{r description, results='asis'}
#| echo: false

cat(uns$dataset_description)

```

```{r schema}
#| echo: false
#| results: "asis"

for (file_name in names(metas)) {
  # only print heading if there are multiple objects
  if (length(metas) > 1) {
    cat("## Preview ", gsub("_", " ", file_name), "\n")
  } else {
    cat("## Preview\n")
  }

  meta <- metas[[file_name]]
  shape <- meta$struct$layers[[1]]$shape
  shape_str <- paste(shape, collapse = " × ")

  cat("AnnData object with n_obs × n_vars = ", shape_str, " with slots:\n\n", sep = "")

  for (struct_name in struc_names) {
    df <- slot_info %>%
      filter(
        file_name == !!file_name,
        struct_name == !!struct_name,
        !is.na(description)
      )

    if (nrow(df) > 0) {
      slot_str <- paste(
        paste0("[`", df$name, "`](", df$internal_reference, "){class=\"quarto-xref\"}"),
        collapse = ", "
      )
      cat("* ", struct_name, ": ", slot_str, "  \n", sep = "")
    }
  }

  cat("\n\n")
}
```


:::{.column-page-inset}

```{r schema_table}
#| echo: false
#| results: "asis"

library(gt)

for (file_name in names(metas)) {
  # only print heading if there are multiple objects
  if (length(metas) > 1) {
    cat("## Reference ", gsub("_", " ", file_name), "\n")
  } else {
    cat("## Reference\n")
  }

  meta <- metas[[file_name]]
  shape <- meta$struct$layers[[1]]$shape
  shape_str <- paste(shape, collapse = " × ")

  cat("AnnData object with n_obs × n_vars = ", shape_str, " with slots:\n\n", sep = "")

  df <- slot_info %>%
    filter(
      file_name == !!file_name,
      !is.na(description)
    ) %>%
    transmute(
      # struct_name = paste0("`", struct_name, "`"),
      struct_name = struct_name,
      name = paste0("`", name, "`"),
      description = description,
      type = ifelse(is.na(type) | type == "", " ", paste0("`", type, "`")),
      dtype = ifelse(is.na(dtype) | dtype == "", " ", paste0("`", dtype, "`")),
      shape_str = ifelse(is.na(shape_str), " ", shape_str)
    )

  gt_out <- df |>
    gt(groupname_col = "struct_name") |>
    cols_label(
      name = "Name",
      description = "Description",
      type = "Type",
      dtype = "Data type",
      shape_str = "Shape"
    ) |>
    fmt_markdown() |>
    cols_width(
      name ~ pct(20),
      type ~ pct(11),
      description ~ pct(47),
      dtype ~ pct(11),
      shape_str ~ pct(11)
    )
  print(gt_out)

  cat("\n\n")
}
```

:::

:::{.hidden}

## Slot crossref data

```{r slots}
#| echo: false
#| results: "asis"

capitalize_first <- function(x) {
  paste0(
    toupper(substring(x, 1, 1)),
    substring(x, 2),
    sep = "",
  )
}

df <- slot_info %>%
  filter(!is.na(description)) %>%
  mutate(
    crossref = paste0(
      "### `", file_name, ".", struct_name, "['", name, "']` {", internal_reference, "}\n\n",

      "In R: `", file_name, "$", struct_name, "[[\"", name, "\"]]`\n\n",

      "Type: `", type, "`",
      ifelse(is.na(dtype), "", paste0(", data type: `", dtype, "`")),
      ifelse(is.na(shape_str), "", paste0(", shape: ", shape_str)),
      "\n\n",

      description, "\n\n"
    )
  )

cat(paste(df$crossref, collapse = "\n"))
```

:::
