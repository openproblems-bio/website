---
title: Design the API
order: 20
engine: knitr
---

{{< include ../_blocks/_clone_repo.qmd >}}
{{< include /_include/_evaluate_code.qmd >}}

When creating a new OpenProblems task, it's essential to design the API for the input/outputs of components and their file formats. The API ensures consistency and interoperability across different components of your task, making it easier for others to contribute and build upon your work. Not only that, but creating API files partially automates the following steps:

* [Selecting and subsetting dataset files](select_datasets.qmd)
* Creating new  [methods](../create_component/add_a_method.qmd) and [metrics](../create_component/add_a_metric.qmd) using the `create_component` method.
* [Automated testing](../create_component/run_tests.qmd) of components using the `src/common/comp_tests/run_and_check_adata.py` unit test.
* Generate [reference documentation](../reference/) are partially automated by having defined these API files.

{{< include /documentation/_figures/_project_structure_task_workflow.qmd >}}

Notice how the Viash components and AnnData files are coloured differently in @fig-task-workflow? We'll need to create API files for each component and AnnData file separately. However, this is actually quite easy to do, as we will show in the following sections.

## Define file formats

When specifying the API file formats, you should describe the contents, structure, and any additional metadata required for the files. This information will be useful for developers to understand the expected file formats and components quickly. Use YAML to define the file formats, as shown below:

Contents of `src/<task_id>/api/anndata_train.yaml`:

```{yaml}
type: file # <1>
description: "The training data" # <2>
example: "resources_test/label_projection/pancreas/train.h5ad" # <3>
info:
  short_description: "Training data" # <4>
  slots:
    ... # <5>
```

1. The type of Viash argument when used in components. This should always be set to `"file"`.
2. Description of the file, useful for quickly understanding what type of data such a file represents. Used for generating reference documentation.
3. An example of this file. This path will be used for unit tests to try to run components with.
4. A short label used to represent the file in diagrams in the reference documentation.
5. The mandatory and optional slots in the AnnData file.

### Example

Here is an example of a file specification API file.

Contents of `src/label_projection/api/anndata_train.yaml`:

````yaml
```{bash}
#| echo: false
#| output: asis
cat src/label_projection/api/anndata_train.yaml
```
````


## Define component type API

Next, we need to define the component API for all component types in your task, including methods, control methods, and metrics.

### Specification

```{yaml}
functionality:
  namespace: "label_projection/methods" # <1>
  info: # <2>
    type: method
  arguments: # <3>
    - name: "--input_train"
      __merge__: anndata_train.yaml
    - name: "--input_test"
      __merge__: anndata_test.yaml
    - name: "--output"
      __merge__: anndata_prediction.yaml
      direction: output
  test_resources:
    - ... # <4>
```

1. The `namespace` for the functionality. It follows the format `<task_name>/<category>`. In this case, the task is "label_projection" and the category is "methods". The namespace is used to group similar components together and ensures that they can be easily found and used within the task.
2. General `info` about the functionality. In this example, it specifies that the functionality type is a "method". This information is used to categorize and describe the component in the overall task.
3. The `arguments` that the component accepts. Each argument has a name (e.g., `--input_train`), and its specification is merged from another YAML file (e.g., `"anndata_train.yaml"`). 
4. The resources and unit tests used for testing the component during development and evaluation.

### Example

Here is an example of a file specification API file.

Contents of `src/label_projection/api/comp_method.yaml`:

````yaml
```{bash}
#| echo: false
#| output: asis
cat src/label_projection/api/comp_method.yaml
```
````

### Applying API to specific component

Use the `__merge__` field to include the component type API and extend it with the specific component details. Here's an example:

```{yaml}
__merge__: ../../api/comp_method.yaml # <1>
functionality:
  name: "knn" # <2>
  info: # <3>
    ...
  resources: # <4>
    # ...
platforms: # <5>
  # ...
```

1. The component type API specification file.
2. The name of the component.
3. The metadata of the component.
4. Resource files of the component (typically a Python or an R script).
5. Platform specification info (typically which Docker image to use and which Python/R packages to install on top of that).