---
title: Add a baseline
order: 50
engine: knitr
---

{{< include ../_blocks/_clone_repo.qmd >}}
{{< include /_include/_evaluate_code.qmd >}}
{{< include /_include/_synchonize_tabs.qmd >}}

A baseline method (or control method) is used to test the relative performance of all other methods, and also as a quality control for the pipeline as a whole. A baseline method can either be a positive control or a negative control. The positive control and negative control methods set a maximum and minimum threshold for performance, so any new method should perform better than the negative control methods and worse than the positive control method.

This guide will show you how to create a new baseline method. Note that the Label Projection task is used throughout the guide, so make sure to replace any occurrences of `"label_projection"` with your task of interest.

:::{.callout-tip}
Make sure you have followed the ["Requirements"](requirements.qmd) and ["Getting started"](getting_started.qmd) pages.
:::
 
## Step 1: Create a new component

Use the `create_component` component to start creating a new baseline method.

::: {.panel-tabset}
## Python
```{bash}
viash run src/common/create_component/config.vsh.yaml -- \
  --task label_projection \
  --type control_method \
  --name my_method_py
```


This creates a new folder at `src/label_projection/control_methods/my_method_py` containing a Viash config and a script.

    tree src/label_projection/control_methods/my_method_py
        ├── script.py         Script for running the method.
        ├── config.vsh.yaml   Config file for method.
        └── ...               Optional additional resources.

## R

```{bash}
viash run src/common/create_component/config.vsh.yaml -- \
  --task label_projection \
  --type control_method \
  --name my_method_r \
  --language r
```


This creates a new folder at `src/label_projection/control_methods/my_method_r` containing a Viash config and a script.

    tree src/label_projection/control_methods/my_method_r
        ├── script.R          Script for running the method.
        ├── config.vsh.yaml   Config file for method.
        └── ...               Optional additional resources.

:::

* A **config file** contains metadata of the component and the dependencies required to run it. In steps 2 and 3 we will fill in the required information.
* A **script** contains the code to run the method. In step 4 we will edit the script. 

:::{.callout-tip}
Use the command `viash run src/common/create_component/config.vsh.yaml -- --help` to get information on all of the parameters if the `create_component` component.
:::

## Step 2: Fill in metadata

```{r, include=FALSE, eval=TRUE}
# set eval to TRUE to make sure is always run, even when profile is not 'evaluate_code'
norm_methods <- list.files("src/datasets/normalization")
norm_methods_str <- paste(paste0("`", norm_methods, "`"), collapse = ", ")
```

The [Viash config](https://viash.io/reference/config/) contains metadata of your method, which script is used to run it, and the required dependencies. 


### Generated config file

This is what the `config.vsh.yaml` generated by the `create_component` component looks like:

:::{.panel-tabset}

### Python

<details><summary>Contents of `config.vsh.yaml`</summary>

````yaml
```{bash}
#| echo: false
#| output: asis
cat src/label_projection/control_methods/my_method_py/config.vsh.yaml
```
````

</details>

### R

<details><summary>Contents of `config.vsh.yaml`</summary>

````yaml
```{bash}
#| echo: false
#| output: asis
cat src/label_projection/control_methods/my_method_r/config.vsh.yaml
```
````

</details>

:::

### Required metadata fields

Please edit `functionality.info` section in the config file to fill in the necessary metadata.

#### `functionality.name`
A unique identifier for the method. Must be written in snake case. Example: `my_new_method`.

#### `functionality.info.pretty_name`

A label for the method used for visualisations and documentation. Example: `"My new method"`.

#### `functionality.info.subtype`

Whether the method is a `"positive_control"` or a `"negative_control"`.

#### `functionality.info.summary`

A one sentence summary of the method. Used for creating short overviews of the components in a task.

#### `functionality.info.description`

An explanation for how the method works. Used for creating reference documentation of a task.

#### `functionality.info.preferred_normalization`

Which normalization method a component _prefers_. Possible values are `r norm_methods_str`. Each value corresponds to a normalization component in the directory [`src/datasets/normalization`](https://github.com/openproblems-bio/openproblems-v2/tree/main/src/datasets/normalization).

#### `__merge__`

The file specified in this field contains information regarding the input and output arguments of the component, as well as a unit test to ensure that the component is functioning properly. Normally you don't need to change this if you gave the right arguments to the `create_component` component.

## Step 3: Add dependencies

Each component has it's own set of dependencies, because different components might have conflicting dependencies.

In the platforms section of the config file update the `setup` definition that describes the packages that need to be installed in the Docker image and are required for your method to run. Note that both `anndata~=0.8` and `pyyaml` are necessary Python package dependencies.

Please check out this [guide](https://viash.io/guide/component/add-dependencies.html) for more information on how to add extra package dependencies.

:::{.callout-note}
**Tip:** After making changes to the components dependencies, you will need to rebuild the docker container as follows:

```{bash class.output="output-details"}
viash run src/label_projection/control_methods/my_method_py/config.vsh.yaml -- \
  ---setup cachedbuild
```

<details><summary>output</summary>
```{bash}
#| echo: false
viash run src/label_projection/control_methods/my_method_py/config.vsh.yaml -- \
  ---setup cachedbuild
```
</details>
:::


## Step 4: Edit script

A component's script typically has five sections:

1. Imports and libraries
2. Argument values
3. Read input data
4. Generate results
5. Write output data to file

### Generated script

This is what the script generated by the `create_component` component looks like:

:::{.panel-tabset}

### Python

<details><summary>Contents of `script.py`</summary>

````python
```{bash}
#| echo: false
#| output: asis
cat src/label_projection/control_methods/my_method_py/script.py
```
````

</details>

### R

<details><summary>Contents of `script.R`</summary>

````r
```{bash}
#| echo: false
#| output: asis
cat src/label_projection/control_methods/my_method_r/script.R
```
````

</details>

:::

### Required sections

#### Imports and libraries

In the top section of the script you can define which packages/libraries the method needs. If you add a new or different package add the dependency to `config.vsh.yaml` in the `setup` field (see above).

#### Argument block

The [Viash code block](https://viash.io/reference/viash_code_block/) is designed to facilitate prototyping, by enabling you to execute directly by running `python script.py` (or `Rscript script.R` for R users). Note that anything between "VIASH START" and "VIASH END" will be removed and replaced with a CLI argument parser when the components are being built by Viash.

Here, the `par` dictionary contains all the `arguments` defined in the `config.vsh.yaml` file (including those from the defined `__merge__` file). When adding a `argument` in the `par` dict **also** add it to the `config.vsh.yaml` in the `arguments` section.

#### Read input data

This section reads any input AnnData files passed to the component.

#### Generate results

This is the most important section of your script, as it defines the core functionality provided by the component. It processes the input data to create results for the particular task at hand.


#### Write output data to file

The output stored in a AnnData object and then written to an `.h5ad` file. The format is specified by the API file specified in the `__merge__` field in the config file.

## Step 5: Try component

Your component's API file contains the necessary unit tests to check whether your component works and the output is in the correct format.

You can test your component by using the following command:

```bash
viash test src/label_projection/control_methods/my_method_py/config.vsh.yaml
```
<details>
  <summary>Output</summary>
```{bash}
#| echo: false
# use knn instead of 'my_method' because the script won't work.
# maybe copy a 'working' script here
viash test src/label_projection/control_methods/majority_vote/config.vsh.yaml
```
</details>

Visit ["Run tests"](run_tests.qmd) for more information on running unit tests and how to interpret common error messages.

You can also run your component on local files using the `viash run` command. For example:

```bash
viash run src/label_projection/control_methods/my_method_py/config.vsh.yaml -- \
  --input_train resources_test/label_projection/pancreas/train.h5ad \
  --input_test resources_test/label_projection/pancreas/test.h5ad \
  --output output.h5ad
```

## Next steps

If your component works, please [create a pull request](create_pull_request.qmd).
