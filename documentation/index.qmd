---
title: Documentation
order: 1
listing:
  id: chapters
  template: ../style/listing.ejs
  type: default
  contents: "./*/index.qmd"
execute:
  echo: false
css: "milestones.css"
---

Welcome to the OpenProblems documentation!

OpenProblems is a framework for machine learning scientists, computational biologists, and single-cell data analysts to benchmark and compare single-cell omics methods on a variety of tasks. We believe that improving reproducibility and transparency in research will accelerate progress in single-cell omics.

This documentation provides an overview of the framework and how to contribute to it. It is organized into the following chapters: 

:::{#chapters}
:::

We encourage everyone who uses OpenProblems to contribute to the framework in any way they can. This can include submitting a pull request to improve the documentation, answering queries on the issue tracker, investigating bugs, reviewing other developers' pull requests, or simply reporting issues and giving a "thumbs up" to relevant issues. 

One simple but important way to contribute is to spread the word about the library by referencing it from your blog and articles, linking to it from your website, or starring it on GitHub to show that you use it. This not only helps us gain more visibility but also encourages others to try out the library and contribute to it. 

[![](images/stargazers.png){width=500px}](https://github.com/openproblems-bio/openproblems/stargazers)

Finally, we want to emphasize that OpenProblems is an inclusive community and we expect all members to adhere to our [code of conduct](fundamentals/philosophy.qmd#inclusiveness). We hope that this documentation helps you get started with OpenProblems and we look forward to your contributions.


<!-- add timeline in D3 -->
## Timeline
:::{#timeline}

:::

```{ojs requires}
ms = require('d3-milestones');
sb = require('@supabase/supabase-js');
```


```{ojs}
createMilestones = (
  title,
  description,
  {
    aggregateBy,
    data,
    distribution,
    mapping,
    optimize,
    onEventClick,
    onEventMouseOver,
    onEventMouseLeave,
    orientation,
    parseTime,
    autoResize,
    urlTarget,
  },
  DIV_ID = 'timeline',
  style = ''
) => {
  iteration++;

  const divId = `${DIV_ID}-${iteration}`;

  function render() {
    const m = milestones(`#${divId}`);

    mapping && m.mapping(mapping);
    aggregateBy && m.aggregateBy(aggregateBy);
    distribution && m.distribution(distribution);
    optimize && m.optimize(optimize);
    onEventClick && m.onEventClick(onEventClick);
    onEventMouseOver && m.onEventMouseOver(onEventMouseOver);
    onEventMouseLeave && m.onEventMouseLeave(onEventMouseLeave);
    orientation && m.orientation(orientation);
    parseTime && m.parseTime(parseTime);
    autoResize && m.autoResize(autoResize);
    urlTarget && m.urlTarget(urlTarget);

    m.render(data);
  }

  // Wait until the wrapping DIV exists, only then render.
  function checkElement() {
    const wrapper = document.getElementById(divId);
    if (!wrapper) {
      window.setTimeout(checkElement, 100);
    } else {
      render();
    }
  }

  checkElement();

  const timeline = `<div id="${divId}" class="timeline" style="${style}"></div>`;

  if (!title && !description) {
    return timeline;
  }

  return `
    <div class="d3Milestones">
      ${title ? `<h2>${title}</h2>` : ''}
      ${description ? `<p>${description}</p>` : ''}
      ${timeline}
    </div>
  `;
};
```



```{ojs supabase_data}
supabase_url="https://bleficzaoyltozjjndha.supabase.co"
supabase_key="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJsZWZpY3phb3lsdG96ampuZGhhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjQyNDI2ODMsImV4cCI6MjAzOTgxODY4M30.fHtpJTveDUF1z07_k7FZX3wLy7bXpkYl5KyA5o_EuQY"
supabase = sb.createClient(supabase_url, supabase_key);

benchmarks = (await supabase
  .from('tasks')
  .select('first_release, name, task_name'))
  .data
  .filter(item => item.first_release !== null)
  .map(item => ({
    date: item.first_release,
    name: item.name,
    task_name: item.task_name.replace(/^task_/, ''),
    character: "benchmark",
    type: "benchmark"
  }));

// Add result links
updatedBenchmarks = benchmarks.map(item => ({
  ...item,
  'url': '../results/' + item.task_name
}))

timeline = (await supabase
  .from('timeline')
  .select('name, date, type'))
  .data
  .map(item => ({
    name: item.name,
    date: item.date,
    type: item.type,
    character: "timeline"
  }));

combinedData = updatedBenchmarks.concat(timeline);

```

<!-- ```{ojs}
Template = (args) => {
  gandalf = createMilestones(
    Object.assign(args, {
      distribution: 'top',
      data: updatedBenchmarks,
    }),
    'timeline-benchmark',
    'height: 200px !important'
  );
  frodo = createMilestones(
    undefined,
    undefined,
    Object.assign(args, {
      distribution: 'bottom',
      data: frodoData,
    }),
    'timeline-frodo',
    'height: 200px !important; margin-top: -200px !important'
  );
  return gandalf + frodo;
};
``` -->


```{ojs timeline}

timelineChart = ms('#timeline')
	.mapping({
		'timestamp': 'date',
		'text': 'name',
    'character': 'character'
	})
  .optimize(true)
	.parseTime('%Y-%m-%d')
	.aggregateBy('month')
	.render(combinedData);


```
