[
    {
        "method_name": "ALRA (log norm)",
        "method_summary": "ALRA (Adaptively-thresholded Low Rank Approximation) is a method for imputation of missing values in single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first imputes values using rank-k approximation, using singular value decomposition. Next, a symmetric distribution is fitted to the near-zero imputed values for each gene (row) of the matrix. The right \u201ctail\u201d of this distribution is then used to threshold the accepted nonzero entries. This same threshold is then used to rescale the matrix, once the \u201cbiological zeros\u201d have been removed.",
        "paper_name": "Zero-preserving imputation of scRNA-seq data using low-rank approximation",
        "paper_reference": "linderman2018zero",
        "paper_year": 2018,
        "code_url": "https://github.com/KlugerLab/ALRA",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "alra_log"
    },
    {
        "method_name": "ALRA (log norm, reversed normalization)",
        "method_summary": "ALRA (Adaptively-thresholded Low Rank Approximation) is a method for imputation of missing values in single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first imputes values using rank-k approximation, using singular value decomposition. Next, a symmetric distribution is fitted to the near-zero imputed values for each gene (row) of the matrix. The right \u201ctail\u201d of this distribution is then used to threshold the accepted nonzero entries. This same threshold is then used to rescale the matrix, once the \u201cbiological zeros\u201d have been removed.",
        "paper_name": "Zero-preserving imputation of scRNA-seq data using low-rank approximation",
        "paper_reference": "linderman2018zero",
        "paper_year": 2018,
        "code_url": "https://github.com/KlugerLab/ALRA",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "alra_log_reversenorm"
    },
    {
        "method_name": "ALRA (sqrt norm)",
        "method_summary": "ALRA (Adaptively-thresholded Low Rank Approximation) is a method for imputation of missing values in single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first imputes values using rank-k approximation, using singular value decomposition. Next, a symmetric distribution is fitted to the near-zero imputed values for each gene (row) of the matrix. The right \u201ctail\u201d of this distribution is then used to threshold the accepted nonzero entries. This same threshold is then used to rescale the matrix, once the \u201cbiological zeros\u201d have been removed.",
        "paper_name": "Zero-preserving imputation of scRNA-seq data using low-rank approximation",
        "paper_reference": "linderman2018zero",
        "paper_year": 2018,
        "code_url": "https://github.com/KlugerLab/ALRA",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "alra_sqrt"
    },
    {
        "method_name": "ALRA (sqrt norm, reversed normalization)",
        "method_summary": "ALRA (Adaptively-thresholded Low Rank Approximation) is a method for imputation of missing values in single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first imputes values using rank-k approximation, using singular value decomposition. Next, a symmetric distribution is fitted to the near-zero imputed values for each gene (row) of the matrix. The right \u201ctail\u201d of this distribution is then used to threshold the accepted nonzero entries. This same threshold is then used to rescale the matrix, once the \u201cbiological zeros\u201d have been removed.",
        "paper_name": "Zero-preserving imputation of scRNA-seq data using low-rank approximation",
        "paper_reference": "linderman2018zero",
        "paper_year": 2018,
        "code_url": "https://github.com/KlugerLab/ALRA",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "alra_sqrt_reversenorm"
    },
    {
        "method_name": "DCA",
        "method_summary": "DCA (Deep Count Autoencoder) is a method to remove the effect of dropout in scRNA-seq data. DCA takes into account the count structure, overdispersed nature and sparsity of scRNA-seq datatypes using a deep autoencoder with a zero-inflated negative binomial (ZINB) loss. The autoencoder is then applied to the dataset, where the mean of the fitted negative binomial distributions is used to fill each entry of the imputed matrix.",
        "paper_name": "Single-cell RNA-seq denoising using a deep count autoencoder",
        "paper_reference": "eraslan2019single",
        "paper_year": 2019,
        "code_url": "https://github.com/theislab/dca",
        "image": "openproblems-python-tensorflow",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "dca"
    },
    {
        "method_name": "KNN smoothing",
        "method_summary": "KNN-smoothing is a method for denoising data based on the k-nearest neighbours. Given a normalised scRNA-seq matrix, KNN-smoothing calculates a k-nearest neighbour matrix using Euclidean distances between cell pairs. Each cell\u2019s denoised expression is then defined as the average expression of each of its neighbours.",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems-python-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "knn_naive"
    },
    {
        "method_name": "Iterative KNN smoothing",
        "method_summary": "Iterative kNN-smoothing is a method to repair or denoise noisy scRNA-seq expression matrices. Given a scRNA-seq expression matrix, KNN-smoothing first applies initial normalisation and smoothing. Then, a chosen number of principal components is used to calculate Euclidean distances between cells. Minimally sized neighbourhoods are initially determined from these Euclidean distances, and expression profiles are shared between neighbouring cells. Then, the resultant smoothed matrix is used as input to the next step of smoothing, where the size (k) of the considered neighbourhoods is increased, leading to greater smoothing. This process continues until a chosen maximum k value has been reached, at which point the iteratively smoothed object is then optionally scaled to yield a final result.",
        "paper_name": "K-nearest neighbor smoothing for high-throughput single-cell RNA-Seq data",
        "paper_reference": "wagner2018knearest",
        "paper_year": 2018,
        "code_url": "https://github.com/yanailab/knn-smoothing",
        "image": "openproblems-python-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "knn_smoothing"
    },
    {
        "method_name": "MAGIC",
        "method_summary": "MAGIC (Markov Affinity-based Graph Imputation of Cells) is a method for imputation and denoising of noisy or dropout-prone single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first calculates Euclidean distances between each pair of cells in the dataset, which is then augmented using a Gaussian kernel (function) and row-normalised to give a normalised affinity matrix. A t-step markov process is then calculated, by powering this affinity matrix t times. Finally, the powered affinity matrix is right-multiplied by the normalised data, causing the final imputed values to take the value of a per-gene average weighted by the affinities of cells. The resultant imputed matrix is then rescaled, to more closely match the magnitude of measurements in the normalised (input) matrix.",
        "paper_name": "Recovering Gene Interactions from Single-Cell Data Using Data Diffusion",
        "paper_reference": "van2018recovering",
        "paper_year": 2018,
        "code_url": "https://github.com/KrishnaswamyLab/MAGIC",
        "image": "openproblems-python-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "magic"
    },
    {
        "method_name": "MAGIC (approximate)",
        "method_summary": "MAGIC (Markov Affinity-based Graph Imputation of Cells) is a method for imputation and denoising of noisy or dropout-prone single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first calculates Euclidean distances between each pair of cells in the dataset, which is then augmented using a Gaussian kernel (function) and row-normalised to give a normalised affinity matrix. A t-step markov process is then calculated, by powering this affinity matrix t times. Finally, the powered affinity matrix is right-multiplied by the normalised data, causing the final imputed values to take the value of a per-gene average weighted by the affinities of cells. The resultant imputed matrix is then rescaled, to more closely match the magnitude of measurements in the normalised (input) matrix.",
        "paper_name": "Recovering Gene Interactions from Single-Cell Data Using Data Diffusion",
        "paper_reference": "van2018recovering",
        "paper_year": 2018,
        "code_url": "https://github.com/KrishnaswamyLab/MAGIC",
        "image": "openproblems-python-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "magic_approx"
    },
    {
        "method_name": "MAGIC (approximate, reversed normalization)",
        "method_summary": "MAGIC (Markov Affinity-based Graph Imputation of Cells) is a method for imputation and denoising of noisy or dropout-prone single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first calculates Euclidean distances between each pair of cells in the dataset, which is then augmented using a Gaussian kernel (function) and row-normalised to give a normalised affinity matrix. A t-step markov process is then calculated, by powering this affinity matrix t times. Finally, the powered affinity matrix is right-multiplied by the normalised data, causing the final imputed values to take the value of a per-gene average weighted by the affinities of cells. The resultant imputed matrix is then rescaled, to more closely match the magnitude of measurements in the normalised (input) matrix.",
        "paper_name": "Recovering Gene Interactions from Single-Cell Data Using Data Diffusion",
        "paper_reference": "van2018recovering",
        "paper_year": 2018,
        "code_url": "https://github.com/KrishnaswamyLab/MAGIC",
        "image": "openproblems-python-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "magic_approx_reverse_norm"
    },
    {
        "method_name": "MAGIC (reversed normalization)",
        "method_summary": "MAGIC (Markov Affinity-based Graph Imputation of Cells) is a method for imputation and denoising of noisy or dropout-prone single cell RNA-sequencing data. Given a normalised scRNA-seq expression matrix, it first calculates Euclidean distances between each pair of cells in the dataset, which is then augmented using a Gaussian kernel (function) and row-normalised to give a normalised affinity matrix. A t-step markov process is then calculated, by powering this affinity matrix t times. Finally, the powered affinity matrix is right-multiplied by the normalised data, causing the final imputed values to take the value of a per-gene average weighted by the affinities of cells. The resultant imputed matrix is then rescaled, to more closely match the magnitude of measurements in the normalised (input) matrix.",
        "paper_name": "Recovering Gene Interactions from Single-Cell Data Using Data Diffusion",
        "paper_reference": "van2018recovering",
        "paper_year": 2018,
        "code_url": "https://github.com/KrishnaswamyLab/MAGIC",
        "image": "openproblems-python-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "magic_reverse_norm"
    },
    {
        "method_name": "No denoising",
        "method_summary": "Denoised outputs are defined from the unmodified input data.",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "no_denoising"
    },
    {
        "method_name": "Perfect denoising",
        "method_summary": "Denoised outputs are defined from the target data.",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "denoising",
        "commit_sha": "49b96d8332797b8b1fe34ba1f998162bb4b18e83",
        "method_id": "perfect_denoising"
    }
]