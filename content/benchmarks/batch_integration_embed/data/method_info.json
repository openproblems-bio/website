[
    {
        "method_name": "Random Integration by Batch",
        "method_summary": "Feature values, embedding coordinates, and graph connectivity are all randomly permuted within each batch label",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "batch_random_integration"
    },
    {
        "method_name": "Random Embedding by Celltype",
        "method_summary": "Cells are embedded as a one-hot encoding of celltype labels",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "celltype_random_embedding"
    },
    {
        "method_name": "Random Embedding by Celltype (with jitter)",
        "method_summary": "Cells are embedded as a one-hot encoding of celltype labels, with a small amount of random noise added to the embedding",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "celltype_random_embedding_jitter"
    },
    {
        "method_name": "Random Graph by Celltype",
        "method_summary": "Cells are embedded as a one-hot encoding of celltype labels. A graph is then built on this embedding",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "celltype_random_graph"
    },
    {
        "method_name": "Random Integration by Celltype",
        "method_summary": "Feature values, embedding coordinates, and graph connectivity are all randomly permuted within each celltype label",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "celltype_random_integration"
    },
    {
        "method_name": "Combat (full/scaled)",
        "method_summary": "ComBat uses an Empirical Bayes (EB) approach to correct for batch effects. It estimates batch-specific parameters by pooling information across genes in each batch and shrinks the estimates towards the overall mean of the batch effect estimates across all genes. These parameters are then used to adjust the data for batch effects, leading to more accurate and reproducible results.",
        "paper_name": "Adjusting batch effects in microarray expression data using empirical Bayes methods",
        "paper_reference": "hansen2012removing",
        "paper_year": 2007,
        "code_url": "https://scanpy.readthedocs.io/en/stable/api/scanpy.pp.combat.html",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "combat_full_scaled"
    },
    {
        "method_name": "Combat (full/unscaled)",
        "method_summary": "ComBat uses an Empirical Bayes (EB) approach to correct for batch effects. It estimates batch-specific parameters by pooling information across genes in each batch and shrinks the estimates towards the overall mean of the batch effect estimates across all genes. These parameters are then used to adjust the data for batch effects, leading to more accurate and reproducible results.",
        "paper_name": "Adjusting batch effects in microarray expression data using empirical Bayes methods",
        "paper_reference": "hansen2012removing",
        "paper_year": 2007,
        "code_url": "https://scanpy.readthedocs.io/en/stable/api/scanpy.pp.combat.html",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "combat_full_unscaled"
    },
    {
        "method_name": "Combat (hvg/scaled)",
        "method_summary": "ComBat uses an Empirical Bayes (EB) approach to correct for batch effects. It estimates batch-specific parameters by pooling information across genes in each batch and shrinks the estimates towards the overall mean of the batch effect estimates across all genes. These parameters are then used to adjust the data for batch effects, leading to more accurate and reproducible results.",
        "paper_name": "Adjusting batch effects in microarray expression data using empirical Bayes methods",
        "paper_reference": "hansen2012removing",
        "paper_year": 2007,
        "code_url": "https://scanpy.readthedocs.io/en/stable/api/scanpy.pp.combat.html",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "combat_hvg_scaled"
    },
    {
        "method_name": "Combat (hvg/unscaled)",
        "method_summary": "ComBat uses an Empirical Bayes (EB) approach to correct for batch effects. It estimates batch-specific parameters by pooling information across genes in each batch and shrinks the estimates towards the overall mean of the batch effect estimates across all genes. These parameters are then used to adjust the data for batch effects, leading to more accurate and reproducible results.",
        "paper_name": "Adjusting batch effects in microarray expression data using empirical Bayes methods",
        "paper_reference": "hansen2012removing",
        "paper_year": 2007,
        "code_url": "https://scanpy.readthedocs.io/en/stable/api/scanpy.pp.combat.html",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "combat_hvg_unscaled"
    },
    {
        "method_name": "FastMNN embed (full/scaled)",
        "method_summary": "fastMNN performs a multi-sample PCA to reduce dimensionality, identifying MNN paris in the low-dimensional space, and then correcting the target batch towards the reference using locally weighted correction vectors. The corrected target batch is then merged with the reference. The process is repeated with the next target batch except for the PCA step.",
        "paper_name": "A description of the theory behind the fastMNN algorithm",
        "paper_reference": "lun2019fastmnn",
        "paper_year": 2019,
        "code_url": "https://doi.org/doi:10.18129/B9.bioc.batchelor",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "fastmnn_embed_full_scaled"
    },
    {
        "method_name": "FastMNN embed (full/unscaled)",
        "method_summary": "fastMNN performs a multi-sample PCA to reduce dimensionality, identifying MNN paris in the low-dimensional space, and then correcting the target batch towards the reference using locally weighted correction vectors. The corrected target batch is then merged with the reference. The process is repeated with the next target batch except for the PCA step.",
        "paper_name": "A description of the theory behind the fastMNN algorithm",
        "paper_reference": "lun2019fastmnn",
        "paper_year": 2019,
        "code_url": "https://doi.org/doi:10.18129/B9.bioc.batchelor",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "fastmnn_embed_full_unscaled"
    },
    {
        "method_name": "FastMNN embed (hvg/scaled)",
        "method_summary": "fastMNN performs a multi-sample PCA to reduce dimensionality, identifying MNN paris in the low-dimensional space, and then correcting the target batch towards the reference using locally weighted correction vectors. The corrected target batch is then merged with the reference. The process is repeated with the next target batch except for the PCA step.",
        "paper_name": "A description of the theory behind the fastMNN algorithm",
        "paper_reference": "lun2019fastmnn",
        "paper_year": 2019,
        "code_url": "https://doi.org/doi:10.18129/B9.bioc.batchelor",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "fastmnn_embed_hvg_scaled"
    },
    {
        "method_name": "FastMNN embed (hvg/unscaled)",
        "method_summary": "fastMNN performs a multi-sample PCA to reduce dimensionality, identifying MNN paris in the low-dimensional space, and then correcting the target batch towards the reference using locally weighted correction vectors. The corrected target batch is then merged with the reference. The process is repeated with the next target batch except for the PCA step.",
        "paper_name": "A description of the theory behind the fastMNN algorithm",
        "paper_reference": "lun2019fastmnn",
        "paper_year": 2019,
        "code_url": "https://doi.org/doi:10.18129/B9.bioc.batchelor",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "fastmnn_embed_hvg_unscaled"
    },
    {
        "method_name": "Harmony (full/scaled)",
        "method_summary": "Harmony is a method that uses PCA to group the cells into multi-dataset clusters, and then computes cluster-specific linear correction factors. Each cell is then corrected by its cell-specific linear factor using the cluster-weighted average. The method keeps iterating these four steps until cell clusters are stable.",
        "paper_name": "Fast, sensitive and accurate integration of single-cell data with Harmony",
        "paper_reference": "korsunsky2019fast",
        "paper_year": 2019,
        "code_url": "https://github.com/lilab-bcb/harmony-pytorch",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "harmony_full_scaled"
    },
    {
        "method_name": "Harmony (full/unscaled)",
        "method_summary": "Harmony is a method that uses PCA to group the cells into multi-dataset clusters, and then computes cluster-specific linear correction factors. Each cell is then corrected by its cell-specific linear factor using the cluster-weighted average. The method keeps iterating these four steps until cell clusters are stable.",
        "paper_name": "Fast, sensitive and accurate integration of single-cell data with Harmony",
        "paper_reference": "korsunsky2019fast",
        "paper_year": 2019,
        "code_url": "https://github.com/lilab-bcb/harmony-pytorch",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "harmony_full_unscaled"
    },
    {
        "method_name": "Harmony (hvg/scaled)",
        "method_summary": "Harmony is a method that uses PCA to group the cells into multi-dataset clusters, and then computes cluster-specific linear correction factors. Each cell is then corrected by its cell-specific linear factor using the cluster-weighted average. The method keeps iterating these four steps until cell clusters are stable.",
        "paper_name": "Fast, sensitive and accurate integration of single-cell data with Harmony",
        "paper_reference": "korsunsky2019fast",
        "paper_year": 2019,
        "code_url": "https://github.com/lilab-bcb/harmony-pytorch",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "harmony_hvg_scaled"
    },
    {
        "method_name": "Harmony (hvg/unscaled)",
        "method_summary": "Harmony is a method that uses PCA to group the cells into multi-dataset clusters, and then computes cluster-specific linear correction factors. Each cell is then corrected by its cell-specific linear factor using the cluster-weighted average. The method keeps iterating these four steps until cell clusters are stable.",
        "paper_name": "Fast, sensitive and accurate integration of single-cell data with Harmony",
        "paper_reference": "korsunsky2019fast",
        "paper_year": 2019,
        "code_url": "https://github.com/lilab-bcb/harmony-pytorch",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "harmony_hvg_unscaled"
    },
    {
        "method_name": "Liger (full/unscaled)",
        "method_summary": "LIGER or linked inference of genomic experimental relationships uses iNMF deriving and implementing a novel coordinate descent algorithm to efficiently do the factorization. Joint clustering is performed and factor loadings are normalised.",
        "paper_name": "Single-Cell Multi-omic Integration Compares and Contrasts Features of Brain Cell Identity",
        "paper_reference": "welch2019single",
        "paper_year": 2019,
        "code_url": "https://github.com/welch-lab/liger",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "liger_full_unscaled"
    },
    {
        "method_name": "Liger (hvg/unscaled)",
        "method_summary": "LIGER or linked inference of genomic experimental relationships uses iNMF deriving and implementing a novel coordinate descent algorithm to efficiently do the factorization. Joint clustering is performed and factor loadings are normalised.",
        "paper_name": "Single-Cell Multi-omic Integration Compares and Contrasts Features of Brain Cell Identity",
        "paper_reference": "welch2019single",
        "paper_year": 2019,
        "code_url": "https://github.com/welch-lab/liger",
        "image": "openproblems-r-extras",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "liger_hvg_unscaled"
    },
    {
        "method_name": "MNN (full/scaled)",
        "method_summary": "MNN first detects mutual nearest neighbours in two of the batches and infers a projection of the second onto the first batch. After that, additional batches are added iteratively.",
        "paper_name": "Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors",
        "paper_reference": "haghverdi2018batch",
        "paper_year": 2018,
        "code_url": "https://github.com/chriscainx/mnnpy",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "mnn_full_scaled"
    },
    {
        "method_name": "MNN (full/unscaled)",
        "method_summary": "MNN first detects mutual nearest neighbours in two of the batches and infers a projection of the second onto the first batch. After that, additional batches are added iteratively.",
        "paper_name": "Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors",
        "paper_reference": "haghverdi2018batch",
        "paper_year": 2018,
        "code_url": "https://github.com/chriscainx/mnnpy",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "mnn_full_unscaled"
    },
    {
        "method_name": "MNN (hvg/scaled)",
        "method_summary": "MNN first detects mutual nearest neighbours in two of the batches and infers a projection of the second onto the first batch. After that, additional batches are added iteratively.",
        "paper_name": "Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors",
        "paper_reference": "haghverdi2018batch",
        "paper_year": 2018,
        "code_url": "https://github.com/chriscainx/mnnpy",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "mnn_hvg_scaled"
    },
    {
        "method_name": "MNN (hvg/unscaled)",
        "method_summary": "MNN first detects mutual nearest neighbours in two of the batches and infers a projection of the second onto the first batch. After that, additional batches are added iteratively.",
        "paper_name": "Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors",
        "paper_reference": "haghverdi2018batch",
        "paper_year": 2018,
        "code_url": "https://github.com/chriscainx/mnnpy",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "mnn_hvg_unscaled"
    },
    {
        "method_name": "No Integration",
        "method_summary": "Cells are embedded by PCA on the unintegrated data. A graph is built on this PCA embedding.",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "no_integration"
    },
    {
        "method_name": "No Integration by Batch",
        "method_summary": "Cells are embedded by computing PCA independently on each batch",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "no_integration_batch"
    },
    {
        "method_name": "Random Integration",
        "method_summary": "Feature values, embedding coordinates, and graph connectivity are all randomly permuted",
        "paper_name": "Open Problems for Single Cell Analysis",
        "paper_reference": "openproblems",
        "paper_year": 2022,
        "code_url": "https://github.com/openproblems-bio/openproblems",
        "image": "openproblems",
        "is_baseline": true,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "random_integration"
    },
    {
        "method_name": "SCALEX (full)",
        "method_summary": "SCALEX is a method for integrating heterogeneous single-cell data online using a VAE framework. Its generalised encoder disentangles batch-related components from batch-invariant biological components, which are then projected into a common cell-embedding space.",
        "paper_name": "Online single-cell data integration through projecting heterogeneous datasets into a common cell-embedding space",
        "paper_reference": "xiong2021online",
        "paper_year": 2022,
        "code_url": "https://github.com/jsxlei/SCALEX",
        "image": "openproblems-python-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scalex_full"
    },
    {
        "method_name": "SCALEX (hvg)",
        "method_summary": "SCALEX is a method for integrating heterogeneous single-cell data online using a VAE framework. Its generalised encoder disentangles batch-related components from batch-invariant biological components, which are then projected into a common cell-embedding space.",
        "paper_name": "Online single-cell data integration through projecting heterogeneous datasets into a common cell-embedding space",
        "paper_reference": "xiong2021online",
        "paper_year": 2022,
        "code_url": "https://github.com/jsxlei/SCALEX",
        "image": "openproblems-python-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scalex_hvg"
    },
    {
        "method_name": "Scanorama (full/scaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_embed_full_scaled"
    },
    {
        "method_name": "Scanorama (full/unscaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_embed_full_unscaled"
    },
    {
        "method_name": "Scanorama (hvg/scaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_embed_hvg_scaled"
    },
    {
        "method_name": "Scanorama (hvg/unscaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_embed_hvg_unscaled"
    },
    {
        "method_name": "Scanorama gene output (full/scaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_feature_full_scaled"
    },
    {
        "method_name": "Scanorama gene output (full/unscaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_feature_full_unscaled"
    },
    {
        "method_name": "Scanorama gene output (hvg/scaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_feature_hvg_scaled"
    },
    {
        "method_name": "Scanorama gene output (hvg/unscaled)",
        "method_summary": "Scanorama is an extension of the MNN method. Other then MNN, it finds mutual nearest neighbours over all batches and embeds observations into a joint hyperplane.",
        "paper_name": "Efficient integration of heterogeneous single-cell transcriptomes using Scanorama",
        "paper_reference": "hie2019efficient",
        "paper_year": 2019,
        "code_url": "https://github.com/brianhie/scanorama",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanorama_feature_hvg_unscaled"
    },
    {
        "method_name": "scANVI (full/unscaled)",
        "method_summary": "ScanVI is an extension of scVI but instead using a Bayesian semi-supervised approach for more principled cell annotation.",
        "paper_name": "Probabilistic harmonization and annotation of single\u2010cell transcriptomics data with deep generative models",
        "paper_reference": "xu2021probabilistic",
        "paper_year": 2021,
        "code_url": "https://github.com/YosefLab/scvi-tools",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanvi_full_unscaled"
    },
    {
        "method_name": "scANVI (hvg/unscaled)",
        "method_summary": "ScanVI is an extension of scVI but instead using a Bayesian semi-supervised approach for more principled cell annotation.",
        "paper_name": "Probabilistic harmonization and annotation of single\u2010cell transcriptomics data with deep generative models",
        "paper_reference": "xu2021probabilistic",
        "paper_year": 2021,
        "code_url": "https://github.com/YosefLab/scvi-tools",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scanvi_hvg_unscaled"
    },
    {
        "method_name": "scVI (full/unscaled)",
        "method_summary": "scVI combines a variational autoencoder with a hierarchical Bayesian model.",
        "paper_name": "Deep generative modeling for single-cell transcriptomics",
        "paper_reference": "lopez2018deep",
        "paper_year": 2018,
        "code_url": "https://github.com/YosefLab/scvi-tools",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scvi_full_unscaled"
    },
    {
        "method_name": "scVI (hvg/unscaled)",
        "method_summary": "scVI combines a variational autoencoder with a hierarchical Bayesian model.",
        "paper_name": "Deep generative modeling for single-cell transcriptomics",
        "paper_reference": "lopez2018deep",
        "paper_year": 2018,
        "code_url": "https://github.com/YosefLab/scvi-tools",
        "image": "openproblems-r-pytorch",
        "is_baseline": false,
        "code_version": null,
        "task_id": "batch_integration_embed",
        "commit_sha": "6cd9e1e3b3b8549a872b901e84b4c7e3d59ae294",
        "method_id": "scvi_hvg_unscaled"
    }
]